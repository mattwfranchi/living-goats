#!/usr/bin/env python3
"""
Playlist Analysis Example

This script analyzes JSON data generated by either the Spotify or Apple Music playlist indexer.
It automatically detects the format and adjusts the analysis accordingly.
"""

import json
import pandas as pd
from pathlib import Path
from collections import Counter
import matplotlib.pyplot as plt
import seaborn as sns

def detect_platform(data):
    """Detect whether the data is from Spotify or Apple Music."""
    if 'playlist_metadata' in data:
        # Check for Spotify-specific fields
        if 'follower_count' in data['playlist_metadata']:
            return 'spotify'
        # Check for Apple Music-specific fields
        elif 'curator_name' in data['playlist_metadata']:
            return 'apple_music'
    return 'unknown'

def load_playlist_data(json_file_path):
    """Load playlist data from JSON file."""
    with open(json_file_path, 'r', encoding='utf-8') as f:
        data = json.load(f)
    
    platform = detect_platform(data)
    return data, platform

def analyze_playlist(data, platform):
    """Perform analysis on the playlist data."""
    
    playlist_info = data['playlist_metadata']
    tracks_df = pd.DataFrame(data['tracks'])
    summary = data['summary']
    
    print(f"ğŸµ PLAYLIST ANALYSIS ({platform.upper()})")
    print("=" * 60)
    
    # Basic info
    print(f"ğŸ“‹ Playlist: {playlist_info['name']}")
    
    if platform == 'spotify':
        print(f"ğŸ‘¤ Owner: {playlist_info.get('owner', 'Unknown')}")
        print(f"ğŸ‘¥ Followers: {playlist_info.get('follower_count', 'Unknown')}")
        print(f"ğŸ”’ Public: {playlist_info.get('public', 'Unknown')}")
    elif platform == 'apple_music':
        print(f"ğŸ‘¤ Curator: {playlist_info.get('curator_name', 'Unknown')}")
        print(f"ğŸ“… Last Modified: {playlist_info.get('last_modified_date', 'Unknown')}")
    
    print(f"ğŸ“Š Total Tracks: {summary['total_tracks']}")
    print(f"â±ï¸  Total Duration: {summary.get('total_duration_hours', summary.get('total_duration_ms', 0) / (1000 * 60 * 60)):.1f} hours")
    
    if platform == 'spotify':
        print(f"ğŸ¤ Unique Artists: {summary.get('unique_primary_artists', summary.get('unique_artists', 0))}")
        print(f"ğŸ¤ All Artists (incl. features): {summary.get('unique_all_artists', 0)}")
        print(f"â­ Average Popularity: {summary.get('average_popularity', 0):.1f}")
        print(f"ğŸ” Explicit Tracks: {summary.get('explicit_tracks', 0)}")
    else:
        print(f"ğŸ¤ Unique Artists: {summary.get('unique_artists', 0)}")
        print(f"ğŸµ Genres: {len(summary.get('genres', []))}")
    
    print(f"ğŸ’¿ Unique Albums: {summary.get('unique_albums', 0)}")
    print()
    
    # Top artists
    print("ğŸ¤ TOP 10 ARTISTS:")
    artist_counts = tracks_df['artist_name'].value_counts().head(10)
    for i, (artist, count) in enumerate(artist_counts.items(), 1):
        print(f"{i:2d}. {artist}: {count} tracks")
    print()
    
    # Platform-specific analysis
    if platform == 'spotify':
        analyze_spotify_specific(tracks_df)
    elif platform == 'apple_music':
        analyze_apple_music_specific(tracks_df)
    
    # Duration analysis
    print("â±ï¸  DURATION ANALYSIS:")
    tracks_df['duration_minutes'] = tracks_df['duration_ms'] / 1000 / 60
    avg_duration = tracks_df['duration_minutes'].mean()
    min_duration = tracks_df['duration_minutes'].min()
    max_duration = tracks_df['duration_minutes'].max()
    
    print(f"Average track duration: {avg_duration:.2f} minutes")
    print(f"Shortest track: {min_duration:.2f} minutes")
    print(f"Longest track: {max_duration:.2f} minutes")
    print()
    
    # Find longest and shortest tracks
    longest_track = tracks_df.loc[tracks_df['duration_minutes'].idxmax()]
    shortest_track = tracks_df.loc[tracks_df['duration_minutes'].idxmin()]
    
    print(f"ğŸ”¥ Longest track: \"{longest_track['name']}\" by {longest_track['artist_name']} ({longest_track['duration_minutes']:.2f} min)")
    print(f"âš¡ Shortest track: \"{shortest_track['name']}\" by {shortest_track['artist_name']} ({shortest_track['duration_minutes']:.2f} min)")
    print()
    
    # Release year analysis
    analyze_release_years(tracks_df)
    
    return tracks_df, platform

def analyze_spotify_specific(tracks_df):
    """Analyze Spotify-specific features."""
    print("ğŸ›ï¸  SPOTIFY AUDIO FEATURES:")
    
    # Check if audio features are available
    if 'audio_features' in tracks_df.columns and tracks_df['audio_features'].notna().any():
        # Extract audio features
        audio_features_df = pd.json_normalize(tracks_df['audio_features'].dropna())
        
        print(f"ğŸ•º Average Danceability: {audio_features_df['danceability'].mean():.2f}")
        print(f"âš¡ Average Energy: {audio_features_df['energy'].mean():.2f}")
        print(f"ğŸ˜Š Average Valence (Happiness): {audio_features_df['valence'].mean():.2f}")
        print(f"ğŸµ Average Tempo: {audio_features_df['tempo'].mean():.1f} BPM")
        print(f"ğŸ”‡ Average Acousticness: {audio_features_df['acousticness'].mean():.2f}")
        print(f"ğŸ¤ Average Speechiness: {audio_features_df['speechiness'].mean():.2f}")
        print()
        
        # Find most danceable and energetic tracks
        tracks_with_features = tracks_df[tracks_df['audio_features'].notna()].copy()
        tracks_with_features['danceability'] = tracks_with_features['audio_features'].apply(lambda x: x.get('danceability', 0))
        tracks_with_features['energy'] = tracks_with_features['audio_features'].apply(lambda x: x.get('energy', 0))
        tracks_with_features['valence'] = tracks_with_features['audio_features'].apply(lambda x: x.get('valence', 0))
        
        most_danceable = tracks_with_features.loc[tracks_with_features['danceability'].idxmax()]
        most_energetic = tracks_with_features.loc[tracks_with_features['energy'].idxmax()]
        happiest = tracks_with_features.loc[tracks_with_features['valence'].idxmax()]
        
        print(f"ğŸ•º Most Danceable: \"{most_danceable['name']}\" by {most_danceable['artist_name']} ({most_danceable['danceability']:.2f})")
        print(f"âš¡ Most Energetic: \"{most_energetic['name']}\" by {most_energetic['artist_name']} ({most_energetic['energy']:.2f})")
        print(f"ğŸ˜Š Happiest: \"{happiest['name']}\" by {happiest['artist_name']} ({happiest['valence']:.2f})")
        print()
    
    # Popularity analysis
    if 'popularity' in tracks_df.columns:
        print("ğŸ“Š POPULARITY ANALYSIS:")
        avg_popularity = tracks_df['popularity'].mean()
        print(f"Average popularity: {avg_popularity:.1f}/100")
        
        most_popular = tracks_df.loc[tracks_df['popularity'].idxmax()]
        least_popular = tracks_df.loc[tracks_df['popularity'].idxmin()]
        
        print(f"ğŸ”¥ Most Popular: \"{most_popular['name']}\" by {most_popular['artist_name']} ({most_popular['popularity']}/100)")
        print(f"ğŸ’ Hidden Gem: \"{least_popular['name']}\" by {least_popular['artist_name']} ({least_popular['popularity']}/100)")
        print()

def analyze_apple_music_specific(tracks_df):
    """Analyze Apple Music-specific features."""
    print("ğŸ APPLE MUSIC FEATURES:")
    
    # Genre analysis
    if 'genre_names' in tracks_df.columns:
        all_genres = []
        for genres in tracks_df['genre_names'].dropna():
            if genres:
                all_genres.extend(genres)
        
        if all_genres:
            genre_counts = Counter(all_genres).most_common(10)
            print("ğŸµ TOP GENRES:")
            for i, (genre, count) in enumerate(genre_counts, 1):
                print(f"{i:2d}. {genre}: {count} tracks")
            print()
    
    # ISRC analysis
    if 'isrc' in tracks_df.columns:
        isrc_count = tracks_df['isrc'].notna().sum()
        print(f"ğŸ·ï¸  Tracks with ISRC: {isrc_count}/{len(tracks_df)}")
        print()
    
    # Content rating
    if 'content_rating' in tracks_df.columns:
        explicit_count = tracks_df['content_rating'].notna().sum()
        print(f"ğŸ” Tracks with content rating: {explicit_count}/{len(tracks_df)}")
        print()

def analyze_release_years(tracks_df):
    """Analyze release year distribution."""
    if 'release_date' in tracks_df.columns:
        # Extract year from release date
        tracks_df['release_year'] = pd.to_datetime(tracks_df['release_date'], errors='coerce').dt.year
        year_counts = tracks_df['release_year'].value_counts().head(10)
        
        if not year_counts.empty:
            print("ğŸ“… TOP RELEASE YEARS:")
            for year, count in year_counts.items():
                if pd.notna(year):
                    print(f"{int(year)}: {count} tracks")
            print()

def create_visualizations(tracks_df, platform, output_dir='playlist_analysis'):
    """Create visualizations of the playlist data."""
    
    # Create output directory
    Path(output_dir).mkdir(exist_ok=True)
    
    # Set style for better looking plots
    plt.style.use('seaborn-v0_8')
    
    # 1. Duration distribution
    plt.figure(figsize=(10, 6))
    tracks_df['duration_minutes'] = tracks_df['duration_ms'] / 1000 / 60
    plt.hist(tracks_df['duration_minutes'], bins=30, alpha=0.7, color='skyblue', edgecolor='black')
    plt.title(f'Distribution of Track Durations ({platform.title()})')
    plt.xlabel('Duration (minutes)')
    plt.ylabel('Number of Tracks')
    plt.grid(True, alpha=0.3)
    plt.savefig(f'{output_dir}/duration_distribution.png', dpi=300, bbox_inches='tight')
    plt.close()
    
    # 2. Top artists
    plt.figure(figsize=(12, 8))
    top_artists = tracks_df['artist_name'].value_counts().head(15)
    top_artists.plot(kind='barh', color='lightcoral')
    plt.title(f'Top 15 Artists by Number of Tracks ({platform.title()})')
    plt.xlabel('Number of Tracks')
    plt.gca().invert_yaxis()
    plt.tight_layout()
    plt.savefig(f'{output_dir}/top_artists.png', dpi=300, bbox_inches='tight')
    plt.close()
    
    # 3. Release year timeline
    if 'release_date' in tracks_df.columns:
        tracks_df['release_year'] = pd.to_datetime(tracks_df['release_date'], errors='coerce').dt.year
        year_counts = tracks_df['release_year'].value_counts().sort_index()
        
        if not year_counts.empty:
            plt.figure(figsize=(12, 6))
            year_counts.plot(kind='line', marker='o', color='green', linewidth=2, markersize=6)
            plt.title(f'Tracks by Release Year ({platform.title()})')
            plt.xlabel('Release Year')
            plt.ylabel('Number of Tracks')
            plt.grid(True, alpha=0.3)
            plt.savefig(f'{output_dir}/release_year_timeline.png', dpi=300, bbox_inches='tight')
            plt.close()
    
    # 4. Spotify-specific visualizations
    if platform == 'spotify':
        create_spotify_visualizations(tracks_df, output_dir)
    
    # 5. Apple Music-specific visualizations
    elif platform == 'apple_music':
        create_apple_music_visualizations(tracks_df, output_dir)
    
    print(f"ğŸ“Š Visualizations saved to {output_dir}/")

def create_spotify_visualizations(tracks_df, output_dir):
    """Create Spotify-specific visualizations."""
    
    # Audio features radar chart
    if 'audio_features' in tracks_df.columns and tracks_df['audio_features'].notna().any():
        audio_features_df = pd.json_normalize(tracks_df['audio_features'].dropna())
        
        # Average audio features
        features_to_plot = ['danceability', 'energy', 'valence', 'acousticness', 'instrumentalness', 'liveness', 'speechiness']
        feature_averages = [audio_features_df[feature].mean() for feature in features_to_plot if feature in audio_features_df.columns]
        
        if feature_averages:
            plt.figure(figsize=(10, 8))
            # Create a scatter plot of audio features
            plt.subplot(2, 2, 1)
            plt.scatter(audio_features_df['energy'], audio_features_df['danceability'], alpha=0.6, color='purple')
            plt.xlabel('Energy')
            plt.ylabel('Danceability')
            plt.title('Energy vs Danceability')
            plt.grid(True, alpha=0.3)
            
            plt.subplot(2, 2, 2)
            plt.scatter(audio_features_df['valence'], audio_features_df['energy'], alpha=0.6, color='orange')
            plt.xlabel('Valence (Happiness)')
            plt.ylabel('Energy')
            plt.title('Valence vs Energy')
            plt.grid(True, alpha=0.3)
            
            plt.subplot(2, 2, 3)
            plt.hist(audio_features_df['tempo'], bins=20, alpha=0.7, color='green', edgecolor='black')
            plt.xlabel('Tempo (BPM)')
            plt.ylabel('Number of Tracks')
            plt.title('Tempo Distribution')
            plt.grid(True, alpha=0.3)
            
            plt.subplot(2, 2, 4)
            plt.scatter(audio_features_df['acousticness'], audio_features_df['instrumentalness'], alpha=0.6, color='red')
            plt.xlabel('Acousticness')
            plt.ylabel('Instrumentalness')
            plt.title('Acousticness vs Instrumentalness')
            plt.grid(True, alpha=0.3)
            
            plt.tight_layout()
            plt.savefig(f'{output_dir}/spotify_audio_features.png', dpi=300, bbox_inches='tight')
            plt.close()
    
    # Popularity distribution
    if 'popularity' in tracks_df.columns:
        plt.figure(figsize=(10, 6))
        plt.hist(tracks_df['popularity'], bins=20, alpha=0.7, color='gold', edgecolor='black')
        plt.title('Spotify Popularity Distribution')
        plt.xlabel('Popularity Score')
        plt.ylabel('Number of Tracks')
        plt.grid(True, alpha=0.3)
        plt.savefig(f'{output_dir}/spotify_popularity.png', dpi=300, bbox_inches='tight')
        plt.close()

def create_apple_music_visualizations(tracks_df, output_dir):
    """Create Apple Music-specific visualizations."""
    
    # Genre distribution
    if 'genre_names' in tracks_df.columns:
        all_genres = []
        for genres in tracks_df['genre_names'].dropna():
            if genres:
                all_genres.extend(genres)
        
        if all_genres:
            genre_counts = Counter(all_genres).most_common(15)
            genres, counts = zip(*genre_counts)
            
            plt.figure(figsize=(12, 8))
            plt.barh(genres, counts, color='lightblue')
            plt.title('Apple Music Genre Distribution')
            plt.xlabel('Number of Tracks')
            plt.gca().invert_yaxis()
            plt.tight_layout()
            plt.savefig(f'{output_dir}/apple_music_genres.png', dpi=300, bbox_inches='tight')
            plt.close()

def main():
    """Main function to run the playlist analysis."""
    
    # Look for JSON files in the playlist_data directory
    data_dir = Path('playlist_data')
    
    if not data_dir.exists():
        print("âŒ No playlist_data directory found. Run the indexer script first.")
        return
    
    json_files = list(data_dir.glob('*.json'))
    
    if not json_files:
        print("âŒ No JSON files found in playlist_data directory.")
        return
    
    # Use the most recent file
    latest_file = max(json_files, key=lambda f: f.stat().st_mtime)
    print(f"ğŸ“‚ Analyzing: {latest_file}")
    print()
    
    # Load and analyze data
    data, platform = load_playlist_data(latest_file)
    
    if platform == 'unknown':
        print("âš ï¸  Could not detect platform. Assuming generic format.")
        platform = 'generic'
    
    tracks_df, platform = analyze_playlist(data, platform)
    
    # Create visualizations
    try:
        create_visualizations(tracks_df, platform)
    except ImportError:
        print("ğŸ“Š Matplotlib not available. Skipping visualizations.")
        print("Install with: pip install matplotlib seaborn")
    except Exception as e:
        print(f"ğŸ“Š Error creating visualizations: {e}")

if __name__ == "__main__":
    main() 